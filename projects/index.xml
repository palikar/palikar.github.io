<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects on SA</title>
    <link>https://palikar.github.io/projects/</link>
    <description>Recent content in Projects on SA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Feb 2020 00:00:00 +0100</lastBuildDate>
    
	<atom:link href="https://palikar.github.io/projects/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Alisp</title>
      <link>https://palikar.github.io/projects/alisp/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0100</pubDate>
      
      <guid>https://palikar.github.io/projects/alisp/</guid>
      <description>Abstract It&amp;rsquo;s has been a long standing idea of mine to just sit down and write a language. Not a complicated one, but also not completely useless one. Alisp is the crystallization of this idea into something concrete. It is a interpreted language based on Emacs-Lisp (elisp). I&amp;rsquo;ve borrowed a lot concepts from there and syntax-wise, Alisp closely follows elisp. By now the core runtime of the language is pretty feature complete and it is possible to run simple to moderately complicated programs.</description>
    </item>
    
    <item>
      <title>Code Manager [PART 1]</title>
      <link>https://palikar.github.io/projects/code_manager/</link>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0100</pubDate>
      
      <guid>https://palikar.github.io/projects/code_manager/</guid>
      <description>Abstract This is my personal tool now for managing my GitHub repositories, some system software that I use and pretty much everything that can be downloaded, compiled locally and then installed on a Debian based Linux system. Through this utility one can quickly download and install random things from all over the internet. I&amp;rsquo;ve always wanted some small program that would allow me to quickly bring my GitHub repositories on my local machine so I end it up writing this in my spare time.</description>
    </item>
    
    <item>
      <title>Compile-Time Graph [PART 1]</title>
      <link>https://palikar.github.io/projects/ctgraph/</link>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0100</pubDate>
      
      <guid>https://palikar.github.io/projects/ctgraph/</guid>
      <description>Abstract CTGraph is a small C++17 project that implements a graph structure that can be used entirely at compile time. It started as just an experiment. I wanted to see just how much computation I can perform at compile time. I was heavily inspired by part of cpp_box. In there Jason Turner has managed to implement a compile-time finite state machine. I thought that Graphs are not too far off of a finite state machine so I decided to give the idea a try.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; things to think about while programming</title>
      <link>https://palikar.github.io/projects/cpp_tips/</link>
      <pubDate>Fri, 27 Jul 2018 00:00:00 +0200</pubDate>
      
      <guid>https://palikar.github.io/projects/cpp_tips/</guid>
      <description>Abstract C++ is hard! C++ is even harder when you want to write good code. There are a lot of things to think about when you write code and if you don&amp;rsquo;t think about them, you are probably going to mess things up. Recently I&amp;rsquo;ve found that one good book (see references) that gives 42 (hehe!) concrete tips on how to be a better c++ programmer. This is my summary of sorts about the contents of said book.</description>
    </item>
    
  </channel>
</rss>