<!DOCTYPE html>
<html lang="en-us" prefix="og: http://ogp.me/ns#">
  
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.70.0" />





<title>C&#43;&#43; things to think about while programming â€¢ SA</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; things to think about while programming"/>
<meta name="twitter:description" content="Several tips that I&#39;ve explained to myself after I read Effective Modern C&#43;&#43;"/>

<meta property="og:title" content="C&#43;&#43; things to think about while programming" />
<meta property="og:description" content="Several tips that I&#39;ve explained to myself after I read Effective Modern C&#43;&#43;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://palikar.github.io/projects/cpp_tips/" />
<meta property="article:published_time" content="2018-07-27T00:00:00+02:00" />
<meta property="article:modified_time" content="2019-10-21T22:20:42+02:00" />


<title itemprop="name">C&#43;&#43; things to think about while programming | SA</title>
<meta property="og:title" content="C&#43;&#43; things to think about while programming | SA" />
<meta name="twitter:title" content="C&#43;&#43; things to think about while programming | SA" />
<meta itemprop="name" content="C&#43;&#43; things to think about while programming | SA" />
<meta name="application-name" content="C&#43;&#43; things to think about while programming | SA" />
<meta property="og:site_name" content="" />

<meta name="description" content="Several tips that I&#39;ve explained to myself after I read Effective Modern C&#43;&#43;" />
<meta itemprop="description" content="Several tips that I&#39;ve explained to myself after I read Effective Modern C&#43;&#43;" />
<meta property="og:description" content="Several tips that I&#39;ve explained to myself after I read Effective Modern C&#43;&#43;" />
<meta name="twitter:description" content="Several tips that I&#39;ve explained to myself after I read Effective Modern C&#43;&#43;" />

<base href="https://palikar.github.io/projects/cpp_tips/">

<link rel="canonical" href="https://palikar.github.io/projects/cpp_tips/" itemprop="url" /> 
<meta name="url" content="https://palikar.github.io/projects/cpp_tips/" />
<meta name="twitter:url" content="https://palikar.github.io/projects/cpp_tips/" /> 
<meta property="og:url" content="https://palikar.github.io/projects/cpp_tips/" />
<meta property="og:locale" content="en">
<meta name="language" content="">


<meta itemprop="image" content="https://palikar.github.io/" />
<meta property="og:image" content="https://palikar.github.io/" />
<meta name="twitter:image" content="https://palikar.github.io/" />
<meta name="twitter:image:src" content="https://palikar.github.io/" /> 

<meta property="og:updated_time" content=2019-10-21T22:20:42&#43;0200 />
Sitemap & RSS Feed Tags
<link rel="sitemap" type="application/xml" title="Sitemap" href="https://palikar.github.io/sitemap.xml" /> 





<link rel="manifest" href="https://palikar.github.io/manifest.json" />


<meta name="theme-color" content="#141414" /> 
<meta name="msapplication-TileColor" content="#141414" />

<meta name="keywords" content="" />
<meta name="imagemode" content="force" />
<meta name="coverage" content="Worldwide" /> 
<meta name="distribution" content="Global" />
<meta name="HandheldFriendly" content="True" /> 
<meta name="msapplication-tap-highlight" content="no" />
<meta name="apple-mobile-web-app-title" content="" /> 
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-touch-fullscreen" content="yes" />

<meta name="twitter:site" content="">
<meta name="twitter:creator" content="" />

<meta name="google-site-verification" content="Dajyx2hCwYPHFFMX4gJOxXtv6swEnwmHw9cQz9pzJvg" />
<meta name="msvalidate.01" content="16753A569B85936F07C0CFBE19FE3BC3"/>


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">








<link rel="stylesheet" href="https://palikar.github.io/scss/hyde-hyde.3c75565bab3232e478f88f766c658c19f0636d9471239f83499bd6ceac04f66c.css" integrity="sha256-PHVWW6syMuR4&#43;I92bGWMGfBjbZRxI5&#43;DSZvWzqwE9mw=">


<link rel="stylesheet" href="https://palikar.github.io/scss/print.e5f87aa9d406c09ad1cb0284b65f42c7e53ea92dc1fe9b6ab366bba96a1344e9.css" integrity="sha256-5fh6qdQGwJrRywKEtl9Cx&#43;U&#43;qS3B/ptqs2a7qWoTROk=" media="print">




<link rel="stylesheet" href="https://palikar.github.io/scss/tocbot.5ef07cebc3c477b54270456f149ee02922479bb7555fd344b2c69f953b0e7e5e.css" integrity="sha256-XvB868PEd7VCcEVvFJ7gKSJHm7dVX9NEssaflTsOfl4=">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://palikar.github.io/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="https://palikar.github.io/favicon.png">
    
    


    <meta charset="utf-8" /> 
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-158773896-1"></script>
    <script>
     window.dataLayer = window.dataLayer || [];
     function gtag(){dataLayer.push(arguments);}
     gtag('js', new Date());

     gtag('config', 'UA-158773896-1');
    </script>
    
</head>


  <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://palikar.github.io/">SA</a>
      </span>
      
        
        
        
        <div class="author-image">
          <img src="https://palikar.github.io/img/profile.jpg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
      
      
      <p class="site__description">
         Development, CS, AI and whatever my little heart desires 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">SA</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="https://palikar.github.io/">
						<span>Home</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="https://palikar.github.io/portfolio/">
						<span>Portfolio</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="https://palikar.github.io/about/">
						<span>About</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="https://palikar.github.io/posts/">
						<span>Blog Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="https://palikar.github.io/projects/">
						<span>Projects</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="https://palikar.github.io/categories/">
						<span>Categories</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/palikar22" rel="me"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a>
	
	
	<a href="https://facebook.com/stanislav.ts" rel="me"><i class="fab fa-facebook-f"></i></a>
	
	
	<a href="https://github.com/palikar" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/stanislav-arnaudov-37b475164" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	<a href="mailto:stanislav_ts@abv.bg" rel="me"><i class="fas fa-at fa-lg" aria-hidden="true"></i></a>
	
</section>

      </div>
    </div>
    


  </div>
</div>

    <div class="content container">
      
    
<article>
  <header>
    <h1>C&#43;&#43; things to think about while programming</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Jul 27, 2018
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="https://palikar.github.io/categories/c&#43;&#43;">C&#43;&#43;</a>
              
          
      
    
    
    
    <br/>
    <i class="fas fa-clock"></i> 37 min read
</div>





  </header>
  
  
  
    <div class="toc-wrapper">
      <input type="checkbox" id="tocToggle">
      <label for="tocToggle">Table of Content</label>
      
        <div class="toc" id="TableOfContents"></div>
      
    </div>
  
  
  <div class="post">
    <h2 id="abstract">Abstract</h2>
<p>C++ is hard! C++ is even harder when you want to write good code. There are a lot of things to think about when you write code and if you don&rsquo;t think about them, you are probably going to mess things up. Recently I&rsquo;ve found that one good book (see references) that gives 42 (hehe!) concrete tips on how to be a better c++ programmer. This is my summary of sorts about the contents of said book.</p>
<h2 id="the-cool-new-things">The cool new things</h2>
<h3 id="rvalue-lvalue-and-move-semantics">Rvalue, lvalue and move semantics</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --> &ldquo;Move semantics&rdquo; is a thing that we have in C++ now (since C++11 actually). It makes a ton of sense once you get it but it may be a little hard to wrap your head around it. At least in the beginning, of course. First off - why do we need move-semantics? For code efficiency! If you know what you are doing, your code can run faster, with fewer object copies and fewer objects created. Second, and perhaps more importantly, what are move semantics? The way I like to think about it - the ability to distinguish between an object that won&rsquo;t be needed after the evaluation of an expression and the ability to do a different thing, if you are dealing with such object.<!-- raw HTML omitted --> Take a look at the following code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">MyObject obj1, obj2;
MyObject new_obj <span style="color:#f92672">=</span> obj1 <span style="color:#f92672">+</span> obj2;
</code></pre></div><p>Let&rsquo;s say that the part <code>obj1 + obj2</code> creates a new object. This new object then gets copied through the copy assignment operator of the class <code>MyObject</code>. This creates another object that is stored in the <code>new_object</code> variable. All in all, two objects were created in this situation. The object that was originally created by <code>obj1 + obj2</code> is&hellip; well, gone. We just copied it and threw it away. Shame on us! Wouldn&rsquo;t it have been nice, if we could have just used that object and just &ldquo;moved&rdquo; it in <code>new_obj</code>. Yes, yes it would! And yes, it is possible. Through move semantics. That kind of object that won&rsquo;t continue to live after the expression evaluation is called <strong>rvalue</strong> object. All other objects are <strong>lvalue</strong>. In the class <code>MyObject</code> we can define a special kind of constructor (move constructor) that &ldquo;creates&rdquo; object from rvalues, i. e. &ldquo;moves&rdquo; the data from the given object in <strong>*this</strong>. So,</p>
<ul>
<li>Lvalue - an object that can be used on the left-hand side of expression; an object with identifiable address;</li>
<li>Rvalue - an object that won&rsquo;t persist after the evaluation of a given expression; no identifiable address</li>
</ul>
<p><em>Note:</em> Every value is either an lvalue or an rvalue!</p>
<h3 id="auto">Auto</h3>
<p>Type deduction for variables. Almost the same rules as the template argument type deduction with one small caveat. Also, in a lot of cases, it allows you to write more efficient code. Example to get you going:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> map;
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> it : map){...} <span style="color:#75715e">//just look how simple that is!!!
</span></code></pre></div><h3 id="smart-pointers">Smart pointers</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --> For an year now, I only hear how the C++ gurus scream how raw pointers are dangerous and will probably cause memory leaks when used so&hellip; smart pointers! For the price of a tiny bit of overhead, you will make harder (but not impossible!) for yourself to do something stupid with your code. Your new two best friends are <code>shared_ptr&lt;&gt;</code> and <code>unique_ptrt&lt;&gt;</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> int_ptr <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>maked_shared<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span>);
std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> float_ptr <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">3.3</span>);
</code></pre></div><p>When it comes to <code>unique_ptr</code>, it&rsquo;s important to know how does one transfer the ownership of an object.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">take_ownership</span>(std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> ptr)
{
  ... <span style="color:#75715e">// now the pointer is mine!
</span><span style="color:#75715e"></span>}
std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[]<span style="color:#f92672">&gt;</span> int_arr_ptr <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[]<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">10</span>);
take_ownership(std<span style="color:#f92672">::</span>move(int_arr_ptr));
</code></pre></div><p><code>shared_ptr</code>, on the other hand, can share their ownership. Again, it&rsquo;s good to know how is this done because you can mess it up.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PtrHolder</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">void</span> save_ptr(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ptr)
    {
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>ptr_ <span style="color:#f92672">=</span> ptr;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ptr_;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
{
  Ptrholder obj;
  std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> int_ptr <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>maked_shared<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">2</span>);
  obj.save_ptr(int_ptr); <span style="color:#75715e">// know there are two references to the int of int_ptr
</span><span style="color:#75715e"></span>}
</code></pre></div><p><strong>Important:</strong> <!-- raw HTML omitted -->Do not<!-- raw HTML omitted --> return or take smart pointers by reference! <!-- raw HTML omitted --> Creating factory methods is also relatively straightforward. Just return them by value! There is however one things to remember about <code>unique_ptr</code> - if the return type does not match the thing you are returning, you ought to use <code>std::move</code>. This holds true even, if the return of the function type is a base class and you are returning derived class (explained <a href="https://stackoverflow.com/questions/39478956/how-does-returning-stdmake-uniquesubclass-work/39479117">here</a>).</p>
<h3 id="some-random-abbreviations">Some random abbreviations</h3>
<p>It is a well-known fact that C++ programmers love their abbreviations. And you know what, it actually makes a lot of sense to know those. The abbreviations in the C++ world reveal some cool, useful and right out elegant concepts that everyone should know about. Also, just to be prepared, C++ programmers are really bad at naming things.</p>
<table>
<thead>
<tr>
<th>Abbreviations</th>
<th>Expansion</th>
</tr>
</thead>
<tbody>
<tr>
<td>RAII</td>
<td>Resource acquisition is initialization</td>
</tr>
<tr>
<td>SFINAE</td>
<td>Substitution failure is not an error</td>
</tr>
<tr>
<td>Pimple</td>
<td>Pointer to implementation</td>
</tr>
<tr>
<td>CRTP</td>
<td>Curiously recurring template pattern</td>
</tr>
<tr>
<td>IIFE</td>
<td>Immediately invoked function expression</td>
</tr>
<tr>
<td>RVO</td>
<td>Return value optimization</td>
</tr>
</tbody>
</table>
<h2 id="tips">Tips</h2>
<h3 id="knowing-your-template-type-deduction-is-a-blessing-dot">Knowing your template type deduction is a blessing.</h3>
<p>So every C++ programmer knows how you can define generic &ldquo;templated&rdquo; functions and then you can call them with different types of arguments. The calling itself will cause the compiler to instantiate the function by replacing the generic type with the deduced type. The thing you should know in this process - how the type is being deduced when it&rsquo;s not given explicitly (i. e.the function is called without the &lt;&gt;-brackets). <!-- raw HTML omitted --> So, based on <code>T</code>, <code>ParamType</code> and <code>expr</code> you have to know what type would be deduced in</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> f(ParamType arg);

f(expr);
</code></pre></div><p>There are several cases to look at.</p>
<h4 id="paramtype-is-a-reference-or-a-pointer">ParamType is a reference or a pointer</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> f(T<span style="color:#f92672">&amp;</span> arg);
</code></pre></div><p>In this case, if <code>expr</code> is a reference type, the reference part is ignored and the rest of the type is taken verbatim.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> cx <span style="color:#f92672">=</span> x;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> rx <span style="color:#f92672">=</span> cx;

f(x); <span style="color:#75715e">// T is is int
</span><span style="color:#75715e"></span>
f(cx); <span style="color:#75715e">// T is const int
</span><span style="color:#75715e"></span>
f(rx); <span style="color:#75715e">// T is again const int
</span></code></pre></div><p><em>Note:</em> This means that depending on how <code>f</code> is called, this may not compile</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
T f(T<span style="color:#f92672">&amp;</span> arg)
{
  T new_var <span style="color:#f92672">=</span> arg;
  new_var <span style="color:#f92672">+=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">// if T is const int, this line here will fail
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> new_var;
}
</code></pre></div><p><!-- raw HTML omitted --> If we now change the definition of <code>f</code> to</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> f(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> arg);
</code></pre></div><p>the things to be &ldquo;ignored&rdquo; during the deduction of T are the <em>reference</em> part <!-- raw HTML omitted -->and<!-- raw HTML omitted --> the <em>const</em> part. This means that in the above examples, T will be deduced to <em>int</em> every time.</p>
<h4 id="paramtype-is-a-universal-reference">ParamType is a Universal Reference</h4>
<p>Here we are getting a little bit fancier with come cool c++11 features. We define <strong>f</strong> like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> f(T<span style="color:#f92672">&amp;&amp;</span> arg);
</code></pre></div><p>In this case</p>
<ul>
<li>if <em>expr</em> is a lvalue, <strong>T</strong> and <strong>ParamType</strong> are deduced to be lvalue reference. This is the only case where <strong>T</strong> is deduced top be a reference.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">f(x); <span style="color:#75715e">// T is int&amp;
</span><span style="color:#75715e"></span>
f(cx); <span style="color:#75715e">// T is cont int &amp;
</span><span style="color:#75715e"></span>
f(rx); <span style="color:#75715e">// T is cont int &amp;
</span></code></pre></div><ul>
<li>if <em>expr</em> is a rvalue - the rules for reference and pointer apply.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">f(<span style="color:#ae81ff">27</span>); <span style="color:#75715e">// T is int
</span></code></pre></div><h4 id="paramtype-is-neither-a-reference-nor-a-pointer">ParamType is neither a reference, nor a pointer</h4>
<p>This is just pass by value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> f(T arg);
</code></pre></div><p>By instantiation we ignore everything except the &ldquo;pure type&rdquo; (i.e. <em>reference</em>, <em>const</em> and/or <em>volatile</em> part are ignored)</p>
<h4 id="bonus">Bonus</h4>
<p>Array arguments decay to pointers so when passing arrays to a template function, the <code>T</code> will be deduced with the rules for pointers.<!-- raw HTML omitted --> One can, however, define e reference to an array so with this &ldquo;trick&rdquo; you can force your <code>T</code> to be deduced to an array type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> f(T<span style="color:#f92672">&amp;</span> arg);

<span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">13</span>];
f(arr) <span style="color:#75715e">// T is int[13]
</span><span style="color:#75715e"></span>       <span style="color:#75715e">// and ParamType is int(&amp;)[13]
</span></code></pre></div><p>&ldquo;int(&amp;)[13]&rdquo; is a reference type to an array with 13 elements&hellip; myeah! With such references to arrays you can write this extraordinary function that will deduce the number of elements in an array at compile time</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t N<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">constexpr</span> std<span style="color:#f92672">::</span>size_t arraySize(T (<span style="color:#f92672">&amp;</span>)[N]) <span style="color:#66d9ef">noexcept</span>
{
  <span style="color:#66d9ef">return</span> N;
}
</code></pre></div><p>And&hellip; with that knowledge, you can now punish people who claim they &ldquo;know C++&rdquo;.</p>
<h3 id="auto-type-deduction-is-also-something-to-thinks-about">auto type deduction is also something to thinks about</h3>
<p>The deduction of auto while used as a &ldquo;type&rdquo; of a local variable behaves almost exactly as the deduction of template types. This means you already know most of the rules.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> cx <span style="color:#f92672">=</span> x;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> rx <span style="color:#f92672">=</span> cx;

<span style="color:#75715e">//case 1
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> xx <span style="color:#f92672">=</span> x; <span style="color:#75715e">//the auto is int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> xcx <span style="color:#f92672">=</span> cx; <span style="color:#75715e">//the auto is const int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> xry <span style="color:#f92672">=</span> rx; <span style="color:#75715e">//the auto is const int
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> xx <span style="color:#f92672">=</span> x; <span style="color:#75715e">//the auto is int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> xcx <span style="color:#f92672">=</span> cx; <span style="color:#75715e">//the auto is int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> xry <span style="color:#f92672">=</span> rx; <span style="color:#75715e">//the auto is int
</span><span style="color:#75715e"></span>

<span style="color:#75715e">//case 2
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> xx <span style="color:#f92672">=</span> x; <span style="color:#75715e">//the auto is int&amp;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> xcx <span style="color:#f92672">=</span> cx; <span style="color:#75715e">//the auto is const int&amp;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> xry <span style="color:#f92672">=</span> rx; <span style="color:#75715e">//the auto is const int&amp;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> x_rvalue <span style="color:#f92672">=</span> <span style="color:#ae81ff">27</span>; <span style="color:#75715e">// the auto is int
</span><span style="color:#75715e"></span>
.
.
.
</code></pre></div><p>So yeah, not much new things here. Just think about what is becoming with the <em>auto</em> in the declaration of the variable. The final type may not be the same as the thing deduced for <em>auto</em>. For that, you&rsquo;ll have to replace the deduced type for the <em>auto</em> in the declaration. <!-- raw HTML omitted --> There is however one caveat with <em>auto</em> type deduction. Consider the snippet:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">x1</span>(<span style="color:#ae81ff">27</span>);
<span style="color:#66d9ef">auto</span> x2{<span style="color:#ae81ff">27</span>};
</code></pre></div><p>This compiles but the types of the variables are probably not what you expect. Both statements look the same and while the <strong>x1</strong> is &ldquo;well behaved&rdquo; and to be expected (it is an int&hellip;surprise!), the type of x2 is <code>std::initializer_list&lt;int&gt;</code>. Yes, <em>auto</em> treats bracketed expressions differently and the general deduced type for them is <code>std::initializer_list&lt;T&gt;</code>. This means that the following code won&rsquo;t compile</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">auto</span> x{<span style="color:#ae81ff">12</span>, <span style="color:#e6db74">&#34;random string&#34;</span>};
</code></pre></div><p>If you try using the bracketed expression with a templated function on the other side, it just won&rsquo;t compile even if the objects in the brackets are all of the same types. Template type deduction just cannot handle bracketed expressions.</p>
<h3 id="decltype-is-cool-little-thing">decltype is cool little thing</h3>
<p>At its core <code>decltype</code> has a simple concept. It takes a single argument and it &ldquo;returns&rdquo; its type. The quotation marks are there because the thing returned thing can be used further as a part of the code. For example, you can declare a new variable with given deduced from <code>decltype</code> type. This is possible:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
<span style="color:#66d9ef">decltype</span>(x) xx <span style="color:#f92672">=</span> <span style="color:#ae81ff">23</span>; <span style="color:#75715e">// xx now has the type of x.... just plain int
</span></code></pre></div><p>This means, however, that <code>decltype</code> introduces a whole new set of rules for deducing a type from an expression. Thankfully, those rules are pretty simple and are what you expect&hellip;mostly as I understand it, <code>decltype</code> gives you exactly the type that was used when declaring the argument. It returns all the &ldquo;reference-y&rdquo; and &ldquo;const-y&rdquo; parts. Everything! <!-- raw HTML omitted --> The primary use of <code>decltype</code> is for specifying a return type of a function that depends on the type of the incoming arguments. Imagine we want to write a generic function that accesses a given index of a given container and returns the object at the index while before that&hellip;it does &ldquo;something&rdquo;. In this situation, you can&rsquo;t know the type of the object at the index(its constness, its referenceness&hellip;). <code>decltype</code> to the rescue. Check this out:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Container, <span style="color:#66d9ef">typename</span> Index<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> doSomethingAndAcess(Container<span style="color:#f92672">&amp;</span> c, Index i) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(c[i])
{
  doSomething();
  <span style="color:#66d9ef">return</span> c[i];
}
</code></pre></div><p>The <strong>auto</strong> at the beginning has nothing to do with auto type deduction. It just delegates the specification of the return type of the function to the end where we have access to the parameters. I believe the whole concept is called <em>trailing return type</em>. <!-- raw HTML omitted --> This is, however, the C++11 way of doing it. C++14 offers a sprinkle of syntactic sugar to &ldquo;turn on&rdquo; <code>decltype</code>-deduction rules for auto. Namely:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Container, <span style="color:#66d9ef">typename</span> Index<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) doSomethingAndAcess(Container<span style="color:#f92672">&amp;</span> c, Index i)
{
  doSomething();
  <span style="color:#66d9ef">return</span> c[i];
}
</code></pre></div><p>This way the type of the return statement will be used as a return type and it will be done in a <code>decltype</code>-y kind of way.</p>
<h3 id="prefer-auto-to-explicit-type-declarations">Prefer auto to explicit type declarations</h3>
<h4 id="general-advantages-of-auto">General advantages of <code>auto</code></h4>
<ul>
<li>
<p>The first and obvious advantage of <code>auto</code> is that it spares a lot of typing. This, by extension, allows you to even not remember the types of certain things. Like&hellip; at this point who even knows what are the complete types of certain iterators! So, things like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> It<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> dwim(It b, It e)
{
  <span style="color:#66d9ef">while</span> (b <span style="color:#f92672">!=</span> e)
  {
    <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>iterator_traits<span style="color:#f92672">&lt;</span>It<span style="color:#f92672">&gt;::</span>value_type var <span style="color:#f92672">=</span> b<span style="color:#f92672">*</span>;
    b<span style="color:#f92672">++</span>;
  }
}
</code></pre></div><p>become</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> It<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> dwim(It b, It e)
{
  <span style="color:#66d9ef">while</span> (b <span style="color:#f92672">!=</span> e)
  {
    <span style="color:#66d9ef">auto</span> var <span style="color:#f92672">=</span> b<span style="color:#f92672">*</span>;
    b<span style="color:#f92672">++</span>;
  }
}
</code></pre></div><p>Awesome!</p>
</li>
<li>
<p>With <code>auto</code> you can define types that are known only to the compiler. Lambdas! Also, since C++14 you can also use <code>auto</code> with lambada&rsquo;s parameters.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">auto</span> derefLess <span style="color:#f92672">=</span> [](<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> p1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> p2){<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>p1 <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>p2};
</code></pre></div></li>
<li>
<p><code>auto</code> forces you to initialize your variables which is almost always something you should do.</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> x1; <span style="color:#75715e">//uninitialized..bad!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> x2; <span style="color:#75715e">// wont&#39;t compile!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> x3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//good!
</span></code></pre></div><ul>
<li><code>auto</code> prevents you from using the wrong type. The official return type of <code>std::vector&lt;T&gt;::size()</code> is <code>std::vector&lt;int&gt;::size_type</code> but a lot of time it is approximated with <em>unsigned</em>. This may cause problems in certain situations. The problems go away if you just use <code>auto</code> for the type of the variable holding the return value of <code>std::vector&lt;&gt;::size()</code>.</li>
<li><em>foreach</em>-loops become easier to type <!-- raw HTML omitted -->and<!-- raw HTML omitted --> you cannot mess up the type of the iterated elements. <strong>Always</strong> use something like:</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m;
...
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> e : m )
{
  <span style="color:#75715e">// e has the &#34;most possible correct&#34; type here
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="explicitly-typed-initializer-idiom">Explicitly typed initializer idiom</h4>
<p>Sometimes <code>auto</code> won&rsquo;t give you the type you desire. In those situations, it&rsquo;s preferable to cast the thing you are assigning to a variable to the desired type and continue with the use of auto.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">auto</span> ep <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(calcEpsilon()); <span style="color:#75715e">// explicitly reducing double to float... good!
</span></code></pre></div><h3 id="nullptr-is-a-pointer-to-nothing-0-and-null-are-not-that">nullptr is a pointer to nothing, 0 and NULL are not that</h3>
<p><code>O</code> and <code>NULL</code> sound so logical but they are not what you probably think they are. <code>0</code> is an <em>int</em>. If the compiler sees <code>0</code> in the context of a pointer it will be interpreted as the null-pointer. There are, however, many situations where the context is not that clear. In a lot of cases, <code>0</code> will be treated as a simple int. <!-- raw HTML omitted --> The same story with <code>NULL</code>. Depending on the implementation it is usually some integral type and it will be treated as a number in situations where you don&rsquo;t expect it to behave like this. <!-- raw HTML omitted --> All problems can be solved, if you just forget about the existence of <code>NULL</code> and <code>0</code> and start using <code>nullptr</code>. <code>nullptr</code> is designed to be a pointer to nothing and pointer is the only way it can be interpreted. The following snippet demonstrates everything:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span>);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">bool</span>);

f(NULL); <span style="color:#75715e">// calls f(int)
</span><span style="color:#75715e"></span>
f(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// calls f(int)
</span><span style="color:#75715e"></span>
f(<span style="color:#66d9ef">nullptr</span>); <span style="color:#75715e">// correctly calls f(void*)
</span></code></pre></div><p>Also, another added bonus to the usage of <code>nullptr</code> is that it is the only thing that gets properly deduced with template functions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Func,
         <span style="color:#66d9ef">typename</span> Mux,
         <span style="color:#66d9ef">typename</span> Ptr<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) loackAndCall(Func func, Mux<span style="color:#f92672">&amp;</span> mutex, Ptr ptr)
{
  MuxGuard <span style="color:#a6e22e">g</span>(mutex);
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">func</span>(ptr);
}

lockAndCall(f1,f1m, <span style="color:#ae81ff">0</span>);       <span style="color:#75715e">// error!
</span><span style="color:#75715e"></span>lockAndCall(f1,f1m, NULL);    <span style="color:#75715e">// error!
</span><span style="color:#75715e"></span>lockAndCall(f1,f1m, <span style="color:#66d9ef">nullptr</span>); <span style="color:#75715e">// finex
</span></code></pre></div><h3 id="alias-declarations-are-better-than-typedef">Alias declarations are better than typedef</h3>
<h4 id="what-even-i-am-talking-about">What even I am talking about</h4>
<p>Brief refresher. This is <code>typedef</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> VecPtr;
</code></pre></div><p>And this is the new cool way of doing the same thing using <code>using</code> (alias declaration)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">using</span> VecPtr std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>;
</code></pre></div><h4 id="advantages-of-using">Advantages of <code>using</code></h4>
<ul>
<li>When dealing with types involving function pointers, <code>using</code> is much easier to swallow.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// which one of those look like the easier to type out and remember
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>FP)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span>);

<span style="color:#66d9ef">using</span> FP <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span>);
</code></pre></div><ul>
<li>Alias declarations can be templetized while <code>typedef</code> cannot. If you want to write template type with <code>typedef</code>, you&rsquo;ll have to define some underling <em>struct</em>. <code>using</code> does not suffer from the same problem.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">using</span> MyAllocList <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span>T, MyAlloc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>

<span style="color:#75715e">// VS.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyAllocList</span> {
  <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span>T, MyAlloc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> type;
}
</code></pre></div><p>It gets even worse when you want to use the type defined with <code>typedef</code>. Then you&rsquo;ll have to use the trailing <code>::type</code> after the type.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">typename</span> MyAllocList<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>type list;
}
</code></pre></div><p>Do yourself a favor, use <code>using</code>!</p>
<h3 id="type-transformations-that-come-in-handy">Type transformations that come in handy</h3>
<p>Sometimes you want to &ldquo;cook&rdquo; yourself some type from some already given template types. For those purposes the standard library offers some predefined type transformations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>remove_const<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>type;
std<span style="color:#f92672">::</span>remove_const_t<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;

std<span style="color:#f92672">::</span>remove_reference<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>type;
std<span style="color:#f92672">::</span>remove_reference_t<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;

std<span style="color:#f92672">::</span>add_lvalue_reference<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>type;
std<span style="color:#f92672">::</span>add_lvalue_reference_t<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;

...
</code></pre></div><h3 id="deleted-functions-are-to-be-used-instead-of-private-ones">Deleted functions are to be used instead of private ones</h3>
<p>In some cases what you want is to prevent certain functions from being called from user code. In the good old day programmers just defined such functions private. The smarter way to do the same thing nowadays is to delete the function. This can even be done from a derived class that wants to &ldquo;hide&rdquo; some of the functions from its base class.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">basic_ios</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> ios_base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  basic_ios(<span style="color:#66d9ef">const</span> basic_ios<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
  basic_ios<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> basic_ios<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
}
<span style="color:#75715e">//this deletes the copy constrctor and the assgiment operator but only for the derived class
</span></code></pre></div><p>By convention deleted functions are to be declared <em>public</em> and not <em>private</em>. <!-- raw HTML omitted --> Also <!-- raw HTML omitted -->any<!-- raw HTML omitted --> function could be deleted, not only member functions of a given class. With deletion you could &ldquo;turn off&rdquo; certain overloads of functions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isLucky</span>(<span style="color:#66d9ef">int</span> number);
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isLucky</span>(<span style="color:#66d9ef">char</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isLucky</span>(<span style="color:#66d9ef">bool</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isLucky</span>(<span style="color:#66d9ef">double</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;

<span style="color:#66d9ef">if</span>(isLucky(<span style="color:#ae81ff">2</span>)){...} <span style="color:#75715e">// fine
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>(isLucky(<span style="color:#e6db74">&#39;2&#39;</span>)){...} <span style="color:#75715e">// error!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>(isLucky(true)){...} <span style="color:#75715e">// error!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>(isLucky(<span style="color:#ae81ff">2.5</span>)){...} <span style="color:#75715e">// error!
</span></code></pre></div><p>Without the deletions the function calls will compile and may not behave the way you expect them to because of the implicit conversations to <em>int</em>.</p>
<h3 id="use-override">Use override</h3>
<h4 id="virtual-functions">Virtual functions</h4>
<p>Refresher again. Which functions are to be considered virtual.</p>
<ul>
<li>the base class function must be declared virtual.</li>
<li>The base and derived function names must be <!-- raw HTML omitted -->identical<!-- raw HTML omitted -->.</li>
<li>Parameter types of the baser and derived function must be <!-- raw HTML omitted -->identical<!-- raw HTML omitted -->.</li>
<li>The <em>constness</em> of the base and derived functions must be <!-- raw HTML omitted -->identical<!-- raw HTML omitted -->.</li>
<li>The return types and exception specifications of the base and derived functions must be <!-- raw HTML omitted -->compatible<!-- raw HTML omitted --></li>
</ul>
<p>Inevitably you will forget those rules and you will think that you are overriding something in a &ldquo;virtual&rdquo; way but you really won&rsquo;t be doing that. So, the advice goes, use <code>override</code> to be explicit. Then you&rsquo;ll have compiler tell you&rsquo;ve done something wrong.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> mf1() <span style="color:#66d9ef">const</span>;
  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf2</span>(<span style="color:#66d9ef">int</span> x);
  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf3</span>() <span style="color:#f92672">&amp;</span>;
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf4</span>() <span style="color:#66d9ef">const</span>;
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> mf1() <span style="color:#66d9ef">override</span>;               <span style="color:#75715e">// won&#39;t compile
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf2</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> x) <span style="color:#66d9ef">override</span>; <span style="color:#75715e">// won&#39;t compile
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf3</span>() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">override</span>;            <span style="color:#75715e">// won&#39;t compile
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mf4</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">override</span>;         <span style="color:#75715e">// won&#39;t compile
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="overloading-on-rvalue-and-lvalue">Overloading on rvalue and lvalue</h4>
<p>You can also overload a function based on weather the <code>*this</code> object is a r- or lvalue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  ...
  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;&amp;</span> data() <span style="color:#f92672">&amp;</span> <span style="color:#75715e">// for lvalue Widgets
</span><span style="color:#75715e"></span>    {
      <span style="color:#66d9ef">return</span> values; <span style="color:#75715e">// return lvalue
</span><span style="color:#75715e"></span>    }

  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> data() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#75715e">// for rvalue Widgets
</span><span style="color:#75715e"></span>    {
      <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>move(values); <span style="color:#75715e">// return rvalue
</span><span style="color:#75715e"></span>    }
};

</code></pre></div><h3 id="think-when-you-need-const-iterator-and-when-iterator">Think when you need const_iterator and when iterator</h3>
<h4 id="const-iterators">Const iterators</h4>
<p>Not that much to say. C++ can optimize the code much better if it deals with <em>constness</em>. Remember to put <code>const</code> before <code>auto</code> when you don&rsquo;t need to change the objects that you iterate.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> e : container){}
</code></pre></div><p>Also, when you use a function that takes iterators to perform something that does not modify the container, use <code>std::cbegin()</code> and <code>std::cend()</code> which are the const versions of <code>std::begin()</code> and <code>std::end()</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>find(values.cbegin(), values.cend(), <span style="color:#ae81ff">1986</span>);
<span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>find(std<span style="color:#f92672">::</span>cbegin(values), std<span style="color:#f92672">::</span>cend(values), <span style="color:#ae81ff">1986</span>);
</code></pre></div><p>This brings the next point.</p>
<h4 id="want-generic-code-use-std-begin-std-end-dot-dot-dot-etc">Want generic code, use std::begin(), std::end(),&hellip; etc</h4>
<p>Sometimes you know that your incoming object is a container but you don&rsquo;t have the guarantee that the <code>container::begin()</code> and <code>container::end()</code> methods are provided. This is the reasons to get in the habit of using <code>std::begin()</code> and <code>std::end()</code>. This makes the things a lot more generic. With them you can do this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> C, <span style="color:#66d9ef">typename</span> V<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> findAndInsert(C<span style="color:#f92672">&amp;</span> container, <span style="color:#66d9ef">const</span> V<span style="color:#f92672">&amp;</span> target, <span style="color:#66d9ef">const</span> V<span style="color:#f92672">&amp;</span> insert)
{
  <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>find(std<span style="color:#f92672">::</span>cbegin(container), values<span style="color:#f92672">::</span>cend(container), target);
  container.insert(insert, it);
}
</code></pre></div><h3 id="noexcept-is-good-and-it-is-to-be-used-carefully">noexcept is good and it is to be used carefully</h3>
<p>Today the C++ compilers are quite the smart little things. Much smarter than before. Therefore they can optimize a lot of things and produce a more efficient binary. <code>noexcept</code> is one of the conditions that must be met for a function to be &ldquo;most optimizable&rdquo;. It means that the function <!-- raw HTML omitted -->cannot<!-- raw HTML omitted --> and <!-- raw HTML omitted -->won&rsquo;t<!-- raw HTML omitted --> emit exception at runtime,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(<span style="color:#66d9ef">int</span> x) <span style="color:#66d9ef">noexcept</span>;
</code></pre></div><p><!-- raw HTML omitted --> Right off the start, we need to say that <code>noexcept</code> is a part of a function&rsquo;s interface. Callers may examine if a function is <code>noexcept</code> and their behavior may depend on it. <code>noexcept</code> is almost as important as <code>const</code>. Think about <code>noexcept</code> in the definition of each function. To not declare a function <code>noexcept</code> is a missed opportunity to tell the compiler and everyone else that your function meets certain conditions. However, be careful, as said before <code>noexcept</code> is part of the interface. Whatever your choice might be, it must not be changed in the long term. Removing <code>noexcept</code> (or adding for that matter) to a function definition may break binary compatibility with other parts of the program that use said function. <!-- raw HTML omitted --> If an exception is emitted from a <code>noexcept</code> function at the runtime, the program will simply terminate. So again, be careful with defining functions <code>noexcept</code>. If your function is <code>noexcept</code> but in the body usage of no-<code>noexcept</code> function is present, you might be in trouble. <!-- raw HTML omitted --> A function may conditionally be <code>noexcept</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, size_t N<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> swap(T (<span style="color:#f92672">&amp;</span>a)[N], T (<span style="color:#f92672">&amp;</span>b)[N]) <span style="color:#66d9ef">noexcept</span>(<span style="color:#66d9ef">noexcept</span>(swap_el(<span style="color:#f92672">*</span>a,<span style="color:#f92672">*</span>b)));
</code></pre></div><p>This function is noexcept only if the condition in the <code>noexcept</code> block is true. In this case, only if the function swap_el applied on two elements of the arrays a and b is <code>noexcept</code>.</p>
<h3 id="constexpr-is-the-new-hot-thing">constexpr is the new hot thing!</h3>
<p><code>constexpr</code> indicates a value(when used for variable definition) that is known during compilation. This is quite different from simply being <em>const</em>. Function parameters can be <em>const</em> but are not known during compilation. This:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</code></pre></div><p>is on the other hand known during compilation. In this example <em>x</em> is a <em>compile-time constant</em>. It can be used in interesting ways. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, x<span style="color:#f92672">&gt;</span> arr; <span style="color:#75715e">// defines array with 5 int elements
</span></code></pre></div><p>At this point, I&rsquo;ll have to mention that, of course, all <code>constexpr</code> objects are <em>const</em> by extension. Not all <em>const</em> objects are <code>constexpr</code> however. <!-- raw HTML omitted --> Things become a lot more interesting once <code>constexpr</code> functions are involved. Those create what is called a <code>constexpr</code> <em>context</em>. This means that those functions could be parsed and executed during compilation given that the provided arguments are known during compilation(i. e. they are defined as <code>constexpr</code>). When the conditions for compile-time executions are not met, the function can also act like a normal function. In C++11 those <code>constexpr</code> functions were limited to a single statement - the return statement. In C++14 however, this limitation is drooped. Simple example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pow</span>(<span style="color:#66d9ef">int</span> base, <span style="color:#66d9ef">int</span> exp) <span style="color:#66d9ef">noexcept</span>
{
  <span style="color:#66d9ef">auto</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> exp; i<span style="color:#f92672">++</span>) res <span style="color:#f92672">*=</span> base;
  <span style="color:#66d9ef">return</span> res;
}
<span style="color:#66d9ef">constexpr</span> size <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>, pow(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">&gt;</span> arr; <span style="color:#75715e">// array of size 9
</span></code></pre></div><p>When I first saw this, it blew my mind! <code>constexpr</code> functions may be executed in <code>constexpr</code> contents only if take literal type. Those include all base types except void but user defined types may also be literal if the define <code>constexpr</code> constructor and may be used in <code>constexpr</code> context if some of their methods are <code>constexpr</code>. This is absolutely valid:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">constexpr</span> Point(<span style="color:#66d9ef">int</span> xval <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">int</span> yval <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">noexcept</span>
    <span style="color:#f92672">:</span>x(xval), y(yval)
    {}

  <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getX</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span>{<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>x;}
  <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getY</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span>{<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>y;}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">int</span> x, y;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
{

  <span style="color:#66d9ef">constexpr</span> Point point(<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>);
}
</code></pre></div><p><code>point</code> can be further used in <code>constexpr</code> functions and those could be executed during compilation. To note is that in C++11 setters for the <em>Point</em>-Class can&rsquo;t be <code>constexpr</code> as they modify the object and therefore they are not even <em>const</em>. Further more, the return types of those are <em>void</em> which is not literal type. C++14 lifts both of these restrictions. So..</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">constexpr</span> Point(<span style="color:#66d9ef">int</span> xval <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">int</span> yval <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">noexcept</span>
    <span style="color:#f92672">:</span>x(xval), y(yval)
    {}

  <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getX</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span>{<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>x;}
  <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getY</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span>{<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>y;}

  <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setX</span>(<span style="color:#66d9ef">int</span> val) <span style="color:#66d9ef">noexcept</span>{<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>x <span style="color:#f92672">=</span> val;}
  <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setY</span>(<span style="color:#66d9ef">int</span> val) <span style="color:#66d9ef">noexcept</span>{<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>y <span style="color:#f92672">=</span> val;}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">int</span> x, y;
}
</code></pre></div><p>This gives us the ability to write something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">constexpr</span> Point <span style="color:#a6e22e">reflection</span>(<span style="color:#66d9ef">const</span> Point<span style="color:#f92672">&amp;</span> p) <span style="color:#66d9ef">noexcept</span>
{
  Point result;
  result.setX(<span style="color:#f92672">-</span>p.getX());
  result.setY(<span style="color:#f92672">-</span>p.getY());
  <span style="color:#66d9ef">return</span> result; <span style="color:#75715e">// returning copy of the object
</span><span style="color:#75715e"></span>}
</code></pre></div><p>If invoked with a <code>constexpr</code> variable of type <em>Point</em> the function will be evaluated at compile time. <!-- raw HTML omitted --> It&rsquo;s important to keep in mind that <code>constexpr</code> is a part of a function&rsquo;s interface. Again, as <code>noexcept</code>, users may rely on this interface. Also, if <code>constexpr</code> is used with <code>constexpr</code> variables in <code>constexpr</code> context <!-- raw HTML omitted --><strong>and</strong><!-- raw HTML omitted --> it has some side effects(as I/O or simply logging something to the standard output) it will cause a compile-time error. So yeah, be careful. <code>constexpr</code> is pretty close to the new <code>const</code> but not quite! <!-- raw HTML omitted --> One final thing. Please do yourself a favor and check out <a href="https://www.youtube.com/watch?v=PJwd4JLYJJY">this</a>! A talk with <a href="https://articles.emptycrate.com/about.html">Jason Turnen</a> and <a href="https://github.com/elbeno">Ben Deane</a> that shows exactly what you can do with <code>constexpr</code>.</p>
<h3 id="the-mutable-keyword-exists-and-you-should-know-about-it">The mutable keyword exists and you should know about it!</h3>
<p>So let&rsquo;s say you have the following class that is used not only by you but by someone that is not you and over whom you have to direct control.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourceProvider</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  ResourceProvider(...){}

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">changeState</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
    {
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>x <span style="color:#f92672">=</span> x;
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>y <span style="color:#f92672">=</span> y;
    }

  <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">getResource</span>() <span style="color:#66d9ef">const</span>
    {
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>expensivecomputation();
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">double</span> expensiveComputation(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) <span style="color:#66d9ef">const</span> {...}
  <span style="color:#66d9ef">double</span> x,y;
}
</code></pre></div><p>Everything is perfect. The <em>getResource</em> function is <code>const</code> and it has no side effect. This is as good as it gets with C++ functions. It&rsquo;s optimizable AF. <!-- raw HTML omitted --> One they, however, one of the clients of the class writes you an email with the complaint that the <code>getResources</code> function is too slow and <code>changeState</code> gets called relatively seldom so they end up caching the result of <code>getResource</code>. &ldquo;Wouldn&rsquo;t it be convenient if the class did that on its own automatically,&rdquo; they say. And yes! It certainly would be nice. So you change your class to:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourceProvider</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  ResourceProvider(...){}

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">changeState</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
    {
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>x <span style="color:#f92672">=</span> x;
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>y <span style="color:#f92672">=</span> y;
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>state_changed <span style="color:#f92672">=</span> true;
    }

  <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">getResource</span>() <span style="color:#66d9ef">const</span>
    {
      <span style="color:#66d9ef">if</span> (state_changed)
      {
        cached_value <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>expensivecomputation();
        state_changed <span style="color:#f92672">=</span> false;
      }

      <span style="color:#66d9ef">return</span> cached_value;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">double</span> expensiveComputation(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) <span style="color:#66d9ef">const</span> {...}
  <span style="color:#66d9ef">double</span> x,y;
  <span style="color:#66d9ef">bool</span> state_changed <span style="color:#f92672">=</span> true;
  <span style="color:#66d9ef">double</span> cached_value;
}
</code></pre></div><p>And&hellip;.it doesn&rsquo;t compile. Sad! <code>getResource</code> has side effects now. It isn&rsquo;t <code>const</code>! It can&rsquo;t <code>const</code>! BAD! You have a few options now:</p>
<ul>
<li>remove the <code>const</code> from the function declaration and the hell breaks loose</li>
<li>use something like <code>const_cast</code> and feel&hellip; like a horrible human being after the fact (plus it&rsquo;s really ugly to do that). I mean&hellip; you are lying with your function interface if you do that</li>
<li>use <code>mutable</code>!!</li>
</ul>
<p>Yes <code>mutable</code> is completely different beast. If you define variable as <code>mutable</code> it can be changed from <em>const</em> functions. Myeah! You rewrite your class.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourceProvider</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  ResourceProvider(...){}

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">changeState</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
    {
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>x <span style="color:#f92672">=</span> x;
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>y <span style="color:#f92672">=</span> y;
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>state_changed <span style="color:#f92672">=</span> true;
    }

  <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">getResource</span>() <span style="color:#66d9ef">const</span>
    {
      <span style="color:#66d9ef">if</span> (state_changed)
      {
        cached_value <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>expensivecomputation();
        state_changed <span style="color:#f92672">=</span> false;
      }

      <span style="color:#66d9ef">return</span> cached_value;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">double</span> expensiveComputation(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) <span style="color:#66d9ef">const</span> {...}
  <span style="color:#66d9ef">double</span> x,y;
  <span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">bool</span> state_changed <span style="color:#f92672">=</span> true;
  <span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">double</span> cached_value;
}
</code></pre></div><p>You ship it. Everyone is happy. The code is clean. You can live in peace with the new knowledge now! Also, watch <a href="https://www.youtube.com/watch?v=tTexD26jIN4">this</a> talk by <a href="http://www.gregcons.com/kateblog/">Kate Gregory</a>. She goes over the problem presented here in much more engaging fashion.</p>
<h3 id="std-unique-ptr-is-for-exclusive-ownership">std::unique_ptr is for exclusive ownership!</h3>
<p>Generally, when you want to use a pointer in the new modern C++ world, your first thought should be &ldquo;Can I use <code>unique_ptr</code> here?&quot;. And yes, this is the preferred way of using &ldquo;pointers&rdquo; these days. <code>unique_ptr</code> can be viewed as small as a raw pointer and for most operations, they behave exactly the same way as raw pointers. <!-- raw HTML omitted --> There are few things to keep in mind while using <code>unique_ptr</code>.</p>
<ul>
<li><code>unique_ptr</code> embodies exclusive ownership. Every <code>unique_ptr</code> that is not empty &ldquo;owns&rdquo; the resource it&rsquo;s holding and you have a guarantee (generally) that this is the only object holding a pointer to the underlying object. The <code>unique_ptr</code> cannot be copied as this would create another holder of the resource so <code>unique_ptr</code>-s are only movable</li>
<li>You can know <!-- raw HTML omitted -->exactly<!-- raw HTML omitted --> when an <code>unique_ptr</code> object would be destroyed and with that the resource released. It is said that one of the greatest features of C++ is the closing brackets <code>}</code>. In order words, the fact that you know the exact moment at which an object will be destroyed and the destructor of the class will be executed for this object. The ramifications for <code>unique_ptr</code> is that the object will be destroyed when the enclosing scope comes to an end. Of course, you could move the <code>unique_ptr</code> before that and transfer its ownership to some other part of the program. The moving was talked about in the <a href="#orgdc1a8fb">beginning</a>.</li>
</ul>
<p><!-- raw HTML omitted --> A typical use of <code>unique_ptr</code> are the factory methods. The factory function could even return different type (from some hierarchy, of course) of an object depending on the inputs input parameters.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D1</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {}

std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Base<span style="color:#f92672">&gt;</span> createObj(<span style="color:#66d9ef">int</span> param1, <span style="color:#66d9ef">double</span> param2)
{
  <span style="color:#66d9ef">if</span> (...)
    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>D1<span style="color:#f92672">&gt;</span>();
  <span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>D2<span style="color:#f92672">&gt;</span>();
}
</code></pre></div><p><!-- raw HTML omitted --> Another thing to know about <code>unique_ptr</code> is its ability to define custom deleter for the object. Normally <code>unique_ptr</code> uses simple <code>delete</code> to destroy the resource it&rsquo;s holding to but this behavior could be overridden.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">auto</span> del_base <span style="color:#f92672">=</span> [](Base <span style="color:#f92672">*</span>object){
                 makeLog(object);
                 ...
                 <span style="color:#66d9ef">delete</span> object;
               };
std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Base, <span style="color:#66d9ef">decltype</span>(del_base)<span style="color:#f92672">&gt;</span> ptr(<span style="color:#66d9ef">new</span> Base(), del_base);
</code></pre></div><h3 id="std-shared-ptr-is-for-shared-ownership">std::shared_ptr is for shared ownership!</h3>
<p>Not having garbage collection in C++ is a curse and a blessing at the same time. The knowledge of when exactly your objects are being destroyed and memory released gives you quite the freedom to write high performing code. On the other hand, this freedom comes with a lot of pitfalls and potential problems that you can introduce into your program. <code>shared_ptr</code> aims to provide you with &ldquo;garbage collection&rdquo;-like solution while staying true to the C++ &ldquo;optimize everything&rdquo; principles. <!-- raw HTML omitted --> <code>shared_ptr</code> implements a reference counting system. Several different <code>shared_ptr</code> objects can hold a pointer to the same underlying resource. The resource will be destroyed only then when all <code>shared_ptr</code> have exited their respective scopes (i.e. are destroyed). There is a little bit of overhead once you bring the whole <em>reference</em>-spiel. The important things to keep in mind:</p>
<ul>
<li><code>shared_ptr</code> are twice the size of a raw pointer</li>
<li>memory for the reference count must be dynamically allocated</li>
<li>Increments and decrements of the reference count must be atomic</li>
<li>Constructing a <code>shared_ptr</code> usually increments the reference count. Why usually? Because move-construction is also construction but it doesn&rsquo;t actually produce &ldquo;new object&rdquo;. The pointer of the old object (the one we are moving from) is just set to <em>null</em>. and the new object takes its place in the world so no new reference is actually created.</li>
<li>Each resource that is managed through <code>shared_ptr</code> has what is called a <em>control block</em>. There the <code>shared_ptr</code> meta-information about he pointer it holds(reference count, custom delete&hellip; ). The <em>control block</em> is allocated on the heap
<ul>
<li><code>std::make_shared</code> always creates new <em>control block</em></li>
<li>A <em>control block</em> is also created when the <code>shared_ptr</code> object is constructed from a unique-ownership pointer (<code>unique_ptr</code>).</li>
<li>A <em>control block</em> is created even when you pass a raw pointer to the constructor of the <code>shared_ptr</code>. If you want a new <code>shared_ptr</code> that manages the same resource, you should copy-construct it from another <code>shared_ptr</code></li>
</ul>
</li>
</ul>
<p>The last point is kinda important. You have to think about the control blocks that are created or else you could end up with several control blocks for the same resource which is a perfect recipe for undefined behavior. Look the following code</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;&gt;</span> processed;
...
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">void</span> process()
    {
      processed.emplace_back(<span style="color:#66d9ef">this</span>);<span style="color:#75715e">// bad!!!
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>The part that is wrong is the passing of a raw pointer to a container of <code>shared_ptr</code>-s. This will create a new control block which <!-- raw HTML omitted -->could<!-- raw HTML omitted --> be not bad but if there are other <code>sahred_ptr</code>-s in some other part of the program that already have control block for the <code>*this</code> object&hellip; <strong>undefined behavior</strong>!! This is, however, a problem that was thought about and a solution exists. Introducing <code>std::enable_shared_from_this&lt;T&gt;</code>. Weird name but it does the trick. If a class inherits from this thing, then it is safe to create <code>shared_ptr</code> from the <code>this</code> pointer. The safe code looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>enable_shared_fro_this<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">void</span> process()
    {
      processed.emplace_back(shared_from_this());<span style="color:#75715e">// good!!!
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><h3 id="pimpl-and-the-proper-way-to-use-it-dot">Pimpl and the proper way to use it.</h3>
<p>Ever heard of <a href="http://www.learncpp.com/cpp-tutorial/17-forward-declarations/">forward declaration</a>. If not go check it out. The Pimpl idiom kinda solves the same problem. If you don&rsquo;t want to clutter your header files with the header files of the classes that you use, you can &ldquo;deffer&rdquo; this &ldquo;implementation detail&rdquo; to the <code>.cpp</code> file. Check this out:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//Wifget.hpp
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
  Widget();
  <span style="color:#f92672">~</span>Widget();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Impl</span>;
  Impl impl<span style="color:#f92672">*</span>;
}
<span style="color:#75715e">//Wifget.cpp
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Gadget.hpp&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Widget.hpp&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Widget</span><span style="color:#f92672">::</span>Impl
{
  std<span style="color:#f92672">::</span>sting name;
  Gadget g1, g2, g3;
  std<span style="color:#f92672">::</span>vecotr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> data;
}

Widget<span style="color:#f92672">::</span>Widget()
  <span style="color:#f92672">:</span>impl(<span style="color:#66d9ef">new</span> Impl);

Widget<span style="color:#f92672">::~</span>Widget()
{
  <span style="color:#66d9ef">delete</span> impl;
}
</code></pre></div><p>Notice how in <code>Widget.hpp</code> we didn&rsquo;t have to include a single header. There is no mention of the headers for the fields in the implementation of the class. The implementation appears only in the <code>.cpp</code> file. This can potentially speed up compilation times as it reduces the compile-dependencies between the classes. <!-- raw HTML omitted --> Now to utilize C++14 we can rewrite the class to use <code>uniqe_ptr</code> for the implementation and write our necessary constructors.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//Wifget.hpp
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
  Widget();
  Widget(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;</span> rhs);
  Widget<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;</span> rhs);
  Widget(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;&amp;</span> rhs);
  Widget<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(Widget<span style="color:#f92672">&amp;&amp;</span> rhs);
  <span style="color:#f92672">~</span>Widget();

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Impl</span>;
  std<span style="color:#f92672">::</span>uniqe_ptr<span style="color:#f92672">&lt;</span>Impl<span style="color:#f92672">&gt;</span> impl;
}
<span style="color:#75715e">//Wifget.cpp
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Gadget.hpp&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Widget.hpp&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Widget</span><span style="color:#f92672">::</span>Impl{..}

    Widget<span style="color:#f92672">::</span>Widget()
      <span style="color:#f92672">:</span>impl(std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">::</span>Impl<span style="color:#f92672">&gt;</span>()){};

Widget<span style="color:#f92672">::</span>Widget(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;&amp;</span> rhs) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
Widget<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(Widget<span style="color:#f92672">&amp;&amp;</span> rhs) <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
Widget<span style="color:#f92672">::~</span>Widget() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

Widget<span style="color:#f92672">::</span>Widget(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;</span> rhs) <span style="color:#f92672">:</span>
  impl(std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">::</span>Impl<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">*</span>rhs.impl)){}

Widget<span style="color:#f92672">&amp;</span> Widget<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Widget<span style="color:#f92672">&amp;</span> rhs)
{
  <span style="color:#f92672">*</span>impl <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>rhs.impl;
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><p><em>Note:</em> Use your header only for a declaration when possible. Also, <code>= defualt</code> is <!-- raw HTML omitted -->implementation<!-- raw HTML omitted --> so put in the <code>.cpp</code> file, not in the header. If in this case, you did that in the header file, the compiler would not how to generate the move constructor and the move assignment operator as an implementation of the calls is <!-- raw HTML omitted -->not<!-- raw HTML omitted --> in the header. In the header the <code>struct Impl</code> is incomplete and <code>*impl</code> is a pointer to incomplete type so the compiler could not deal with that. <!-- raw HTML omitted --> The compiler happily generates the move constructors for us as the default implementation is exactly the thing we want. Just perform <em>move</em> on the implementation. The default copy constructors, however, would only perform a shallow copy of the object so we have to write them ourselves. <!-- raw HTML omitted --> The detractor is also the default one because we have no code to put in it. The <code>unique_ptr</code> automatically deletes its contents once it is destroyed.</p>
<h3 id="std-forward-and-std-move-are-quite-interesting-dot">std::forward and std::move are quite interesting.</h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --> Ok, hopefully by now you at least have heard of <strong>move semantics</strong>. Inevitably you&rsquo;ve also probably seen <code>std::move()</code> and <code>std::forward&lt;T&gt;()</code> used in some weird way and wondered &ldquo;What the hell is happening here?&quot;. The first thing to understand about hose functions - they are functions that don&rsquo;t do much in run-time. They don&rsquo;t generate code. They don&rsquo;t &ldquo;move&rdquo;. At their core, those functions are casts. They cast <em>rvalue</em> object to <em>lvalue</em> ones. Refer to one of the <a href="#org1edb870">intro sections</a> for more information about what are those. The difference between <code>std::move()</code> and <code>std::forward&lt;T&gt;()</code> is that they perform the cast under different conditions. <code>std::move()</code> performs it always with no conditions. <code>std::forward&lt;T&gt;()</code> casts to revalue only if a certain condition is met - if the argument is bind to rvalue. <!-- raw HTML omitted --> Yes, it is well known and by this point accepted fact that <code>std::move()</code> has confusing AF name but&hellip; just roll with it and it will grow on you. <code>std::move()</code> doesn&rsquo;t actually move anything. <code>std::move()</code> merely makes an object eligible for moving. This is no guarantee however that an object will be moved from. Consider this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Anotation</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  std<span style="color:#f92672">::</span>string text;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  Anotation(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string name)<span style="color:#f92672">:</span> text(std<span style="color:#f92672">::</span>move(name)){}
  <span style="color:#75715e">//this doesn&#39;t do what it seems to do
</span><span style="color:#75715e"></span>}
Anotation(<span style="color:#e6db74">&#34;ano&#34;</span>);
</code></pre></div><p>Think about what is happening here. We are passing a string to the constructor which takes it by value and &ldquo;moves&rdquo; its content inside the <code>text</code> field. But there is also <code>const</code>. This means that the result of the <code>std::move(name)</code> is <em>rvalue const std::string</em>. The constness is still there. This means that the move constructor of <code>std::string</code> <!-- raw HTML omitted -->cannot<!-- raw HTML omitted --> be used as it will change the object that it takes which is <em>const</em>. For that reason, the ordinary constructor is called and the value is just copied and not moved. The lesson to be learned here - rvalue objects will not be moved sorely on the fact that they are <em>rvalue/s. They also must be /const</em>. <!-- raw HTML omitted --> As already said <code>std::forward&lt;T&gt;()</code> only casts to rvalue if the argument is bound to rvalue object. <code>std::forward&lt;T&gt;()</code> is typically used in cases where <em>perfect forwarding</em> is required. That is, a function takes some arguments and those are automatically <em>lvalue</em> in the function body even if the fiction is invoked with <em>rvalue/s. In the body, however, you may want to &ldquo;forward&rdquo; the argument to other functions that may need to differentiate between /r-</em> and <em>lvalues</em>. In this case, one would use <code>std::forward&lt;T&gt;()</code>. Example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> logAndProcess(T<span style="color:#f92672">&amp;&amp;</span> param)
{
  <span style="color:#66d9ef">auto</span> now <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>system_clock<span style="color:#f92672">::</span>now();
  makeEntry(<span style="color:#e6db74">&#34;Calling process&#34;</span>, now);
  <span style="color:#75715e">/* Here we dont&#39;t know whether the function was invoed
</span><span style="color:#75715e">   with rvalue or lvalue. Therefore we forward the
</span><span style="color:#75715e">   argument perfectly */</span>
  process(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(param));
}
</code></pre></div><h3 id="universal-references-and-rvalue-references">Universal references and rvalue references</h3>
<p>First things first - &ldquo;universal reference&rdquo; is a lie. There is no such thing in the official C++ specification. There there is &ldquo;forwarding reference&rdquo;. &ldquo;Forwarding reference&rdquo; is absolutely the same thing as what Scott Meyers means with &ldquo;universal reference&rdquo; in his book. Here I will also use universal reference. OK? OK. Good that now this is out of the way. <!-- raw HTML omitted --> We know that we can define functions that take rvalue references like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(Widget<span style="color:#f92672">&amp;&amp;</span> param);
</code></pre></div><p>Here <code>param</code> is <em>rvalue</em> reference and it binds only to <em>rvalue</em> objects. Consider on the other hand this function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> g(T<span style="color:#f92672">&amp;&amp;</span> param);
</code></pre></div><p>Here param can bind to <em>rvalues</em> <!-- raw HTML omitted -->and<!-- raw HTML omitted --> to <em>lvalues</em>. This is what makes it <em>universal reference</em>. <!-- raw HTML omitted --> For a reference to be universal one certain condition must be met</p>
<ol>
<li>Type deduction must occur</li>
<li>The reference must have exactly the form &ldquo;T&amp;&amp;&quot;. No <code>const</code>, no nothing. Just &ldquo;T&amp;&amp;&quot;.</li>
</ol>
<p>If the <code>const</code> qualifier is used for the function parameter, it(the parameter) will &ldquo;collapse&rdquo; <em>rvalue const reference</em> which pretty useless on itself as we say in the <a href="#org2e5602b">previous tip</a>. <!-- raw HTML omitted --> As stated if universal reference is bound to &ldquo;rvalue&rdquo;, it is an &ldquo;rvalue&rdquo;-reference and &ldquo;lvalue&rdquo;-reference if it&rsquo;s bound to an &ldquo;lvalue&rdquo;. This means that universal references are exactly the things to be used with <code>std::forward&lt;T&gt;()</code>.</p>
<h3 id="pass-by-value-is-not-what-your-first-c-book-would-have-you-believe"><em>Pass by value</em> is not what your first C++ book would have you believe</h3>
<p>Maybe this is exclusive to me but when I was learning C++ I was left with the impression that passing things by value is kinda dumb if you can pass it by reference. I mean, who needs the extra copy, right?! Not quite. Consider the case of a simple setter</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setName</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> name)
    {
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>name <span style="color:#f92672">=</span> name;
    }
}
</code></pre></div><p>What you actually are doing is:</p>
<ul>
<li>take a string by reference</li>
<li>copy it in the field <code>name</code></li>
</ul>
<p>The copy is still there! It&rsquo;s just that <!-- raw HTML omitted -->you<!-- raw HTML omitted --> performed the copying and not the compiler. Now, this is kinda sub-optimal. The compiler <!-- raw HTML omitted -->is<!-- raw HTML omitted --> smarter than you. After the compiler has copied the value from the caller in the function&rsquo;s parameter we can - enter modern C++ - <em>move</em> it in the corresponding field:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setName</span>(std<span style="color:#f92672">::</span>string name)
    {
      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>name <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(name);
    }
}
</code></pre></div><p>This looks like good modern c++. Copying&hellip; is not that bad as might you think. Compilers are pretty good these days. Do not be mislead. A copy of a single string has virtually no overhead. <!-- raw HTML omitted --> Still, there still exists a time and place for passing by <em>const references</em>. If you actually don&rsquo;t need a copy of the passed argument, then there is no reason for pass-by-value</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Widget</span>
{
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">process</span>(<span style="color:#66d9ef">const</span> Gadget<span style="color:#f92672">&amp;</span> gadget)
    {
      <span style="color:#75715e">// now we can only use const functions of Gadget
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span>(gadget.getNumberOfTicks){....}
    }
}
</code></pre></div><p>Passing pure references also makes sense in some situations:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> names;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">populate</span>(std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> name)
{
  name.pusb_back(<span style="color:#e6db74">&#34;Stanislv&#34;</span>);
  name.pusb_back(<span style="color:#e6db74">&#34;Marina&#34;</span>);
}
populete(names);
</code></pre></div><p>To summarize (taken from an answer from <a href="https://stackoverflow.com/questions/7592630/is-pass-by-value-a-reasonable-default-in-c11">this</a> StackOverflow question)</p>
<table>
<thead>
<tr>
<th>Signature</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>bar(foo f);</td>
<td>want to obtain a copy of</td>
</tr>
<tr>
<td>bar(const foo&amp; f);</td>
<td>want to read f</td>
</tr>
<tr>
<td>bar(foo&amp; f);</td>
<td>want to modify f</td>
</tr>
</tbody>
</table>
<h3 id="return-value-optimization--rvo--don-t-return-std-move-of-local-variable">Return value optimization(RVO) - don&rsquo;t return std:::move of local variable</h3>
<p>With your awesome new knowledge about move-semantics you can now write highly optimized, highly performant code that will go \*whoosh\* past those pesky languages running on virtual machines. You will, however, be tempted to make some &ldquo;optimizations&rdquo; at places where you really shouldn&rsquo;t mess with the compiler. Please always repeat to yourself &ldquo;The compiler is smarter than me!&quot;. <!-- raw HTML omitted --> Consider the following snippet:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Widget <span style="color:#a6e22e">makeWIdget</span>()
{
  Widget w;
  ...;
  <span style="color:#66d9ef">return</span> w;
}
</code></pre></div><p>We are creating a local variable in a function and we are returning it by value. We think about what is happening. The object is created - construction, the object is returned by value - we <!-- raw HTML omitted -->copy<!-- raw HTML omitted --> our new object and return the copy because the local object will be destroyed once the scope of the function ends. Copy! We know what <em>rvlaues</em> are. We don&rsquo;t need any copy. We can move! We rewrite the code like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Widget <span style="color:#a6e22e">makeWIdget</span>()
{
  Widget w;
  ...;
  <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>move(w);
}
</code></pre></div><p>Awesome, we saved ourselves one copy! <strong>Wrong!!!</strong> <!-- raw HTML omitted --> Introducing <em>Return Value Optimization</em>. In some situations(most of them) the compiler will notice that you are returning a local variable by value. If certain conditions are met, the compiler will construct this local object in the exact place in memory where the return value of the function will reside after the function is invoked. In such cases, the return statement won&rsquo;t produce copy <!-- raw HTML omitted -->nor<!-- raw HTML omitted --> will move construction would be necessary. This is good! The conditions that should be met for RVO to occur:</p>
<ol>
<li>The type of the local object must be the same as the return value.</li>
<li>The local object is being returned.</li>
<li>The type is move-constructible.</li>
</ol>
<p>What happens when we <code>std::move</code> the local object - we crate reference to it and RVO can&rsquo;t be performed. So, <strong>don&rsquo;t</strong> return <code>std::move</code>! <!-- raw HTML omitted --> Ok, but still. RVO is just an optimization. Maybe the compiler won&rsquo;t be able to figure out which local object we want to return and will punish us with a copy while returning. No! Again - &ldquo;The compiler is smarter than me!&quot;. Return values are <!-- raw HTML omitted -->always<!-- raw HTML omitted --> treated as <em>rvalues</em>. So when your function is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Widget <span style="color:#a6e22e">makeWIdget</span>()
{
  Widget w;
  ...;
  <span style="color:#66d9ef">return</span> w;
}
</code></pre></div><p><!-- raw HTML omitted -->and<!-- raw HTML omitted --> the compiler can&rsquo;t do RVO, what it effectively sees is :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Widget <span style="color:#a6e22e">makeWIdget</span>()
{
  Widget w;
  ...;
  <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>move(w);
}
</code></pre></div><p>So no. You would never need to return with <code>std::move</code> of local object.</p>
<h3 id="std-async-is-something-that-exists-and-it-s-generally-to-be-preferred-over-std-thread-dot">std::async is something that exists and it&rsquo;s generally to be preferred over std::thread.</h3>
<p>A lot of times you will want to run something asynchronously in your program. C++ and the standard library make this relatively easy and give you two approaches.</p>
<ul>
<li><code>std::thread</code> - for <em>thread-based</em> strategy</li>
<li><code>std::async</code> - for <em>task-based</em> strategy</li>
</ul>
<p>In general, you should prefer <code>std::async</code>. It works on a higher level of abstraction than <code>std::thread</code> and it hides some of the details that you can mess up and delegates them to the implementation. The basic asynchronous call goes like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doAsyncWork</span>();

<span style="color:#66d9ef">auto</span> fut <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>async(doAsyncWork); <span style="color:#75715e">// fut is a future
</span></code></pre></div><p>A further reason why <code>std::async</code> is better is because with it we can get the result from the function that we are calling asynchronously through the future&rsquo;s <em>get</em> method. There isn&rsquo;t really a straight forward way of extracting a result from a separate thread constructed with <code>std::thread</code>. <!-- raw HTML omitted --> If you opt to use thread-based programming you&rsquo;ll have to deal with thread exhaustion, over-subscription, load balancing, and adaptation to new platforms. And you know&hellip;all of these are super fun to deal with. You may have to do it sometimes thou. As stated, threads are lower level concurrency API. Threads may allow you to write more efficient code suited to your specific needs. Cases where threads may be necessary</p>
<ul>
<li>You want to mess directly with the concurrency API provided by the OS. Given this would be pretty hard, it could potentially lead to tremendous speed when done right. Essentially you would have to define the way how your program communicates with the OS as &ldquo;real&rdquo; threads are managed by it.</li>
<li>You know exactly what your needs are and you want to deal with threads and build the whole multi-threading and asynchronous code/system yourself. This is pretty doable and could be a nice learning experience. You probably will implement something that already exists but hey, that&rsquo;s how you learn new things and I would actually encourage this.</li>
<li>If you are implementing some concurrency technology that is not offered by C++, yeah, you bet you&rsquo;ll need to use threads and deal with them.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>I just want to say one thing. Never, never say that you &ldquo;know C++&rdquo; and be deeply skeptical of people who use the said expression. C++ is complex and you can do everything in a lot of different ways and probably things are going to work no matter what. However, some solutions in C++ are very clearly better than others and a lot of times it is not clear what is the &ldquo;optimal&rdquo; way of achieving your goal. Do not be mislead by your knowledge! C++ offers you an ever-expanding world of good\bad solutions and knowing everything that there is to know is most likely infeasible. And you know what, that&rsquo;s actually OK. Because let&rsquo;s face it, software engineering is all about learning something new every day in the process of horribly breaking your code.</p>
<h2 id="references">References</h2>
<p>I&rsquo;m very thankful to these sources:</p>
<ul>
<li><a href="https://www.amazon.de/Effective-Modern-Specific-Ways-Improve/dp/1491903996">Effective modern C++</a> - the book am talking about in this post</li>
<li><a href="https://www.chromium.org/developers/smart-pointer-guidelines">Smart pointers guidelines</a> - a very useful guide on how to be smart with your smart pointers</li>
<li><a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c">Understanding the meaning of lvalue or rvalues</a> - a good blog post that will walk you through the usages and the meaning of move semantics and how are they implemented through <em>rvalue</em> and <em>lvalue</em>.</li>
</ul>
<p>Check them out if you want to be a better C++ programmer.</p>

  </div>
  

<div class="navigation navigation-single">
    
    
    <a href="https://palikar.github.io/projects/ctgraph/" class="navigation-next">
      <span class="navigation-tittle">Compile-Time Graph [PART 1]</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  
    
        <div id="disqus_thread"></div>
<script type="text/javascript">
    

    (function () {
    if (location.hostname === "localhost" ||
      location.hostname === "127.0.0.1" ||
      location.hostname === "") {
      return;
    }
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    var disqus_shortname = 'palikar-github-io';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || 
      document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<noscript>
  Please enable JavaScript to view the
  <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by
  <span class="logo-disqus">Disqus</span>
</a>

    


</article>


    </div>
    
    

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-158773896-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/cmake.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/lisp.min.js"></script>
            
                <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/elisp.min.js"></script>
            
        
    
    <script type="text/javascript">
        
        hljs.configure({languages: ["cmake, lisp, elisp"]});
        
        hljs.initHighlightingOnLoad();
    </script>
    




<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.js"></script>
<script type="text/javascript">
  if (tocbot) {
    tocbot.init({
      
      tocSelector: '.toc',
      
      contentSelector: '.post',
      
      headingSelector: 'h2, h3, h4',
      collapseDepth: 4
    });
  }
</script>



    



  </body>
</html>
